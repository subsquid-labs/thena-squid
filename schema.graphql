type User @entity {
    id: ID!
    balance: BigInt!
    firstInteractAt: DateTime!
    trades: [Trade!]! @derivedFrom(field: "user")
}

type Trade @entity {
    id: ID!

    # meatadata
    blockNumber: Int!
    timestamp: DateTime!
    txHash: String!

    user: User!

    # in
    tokenIn: Token!
    amountIn: BigInt!
    amountInUSD: Float!

    # out
    tokenOut: Token!
    amountOut: BigInt!
    amountOutUSD: Float!

    routes: [String!]!
}

type Swap @entity {
    id: ID!

    # meatadata
    blockNumber: Int!
    timestamp: DateTime!
    txHash: String!

    # in
    tokenIn: Token!
    amountIn: BigInt!
    amountInUSD: Float!

    # out
    tokenOut: Token!
    amountOut: BigInt!
    amountOutUSD: Float!

    trade: Trade!
    pool: Pool!
}

enum PoolType {
    Solidly
    Algebra
    Hypervisor
}

type Pool @entity {
    id: ID!

    type: PoolType!
    factory: String

    # token0
    token0: Token!
    reserve0: BigInt!
    price0: BigInt

    # token1
    token1: Token!
    reserve1: BigInt!
    price1: BigInt

    liquidity: BigInt!
    stable: Boolean
    sqrtPriceX96: BigInt
}

type LiquidityPosition @entity {
    id: ID!

    user: User!
    pool: Pool!

    value: BigInt!

    updates: [LiquidityPositionUpdate!]! @derivedFrom(field: "position")
}

type LiquidityPositionUpdate @entity {
    id: ID!

    blockNumber: Int!
    timestamp: DateTime!
    txHash: String!

    position: LiquidityPosition!

    amount: BigInt!

    amount0: BigInt!
    amount1: BigInt!
}

type Token @entity {
    id: ID!
    decimals: Int!
    symbol: String!
    bnbPrice: BigInt!
    priceMetadata: TokenPriceMetadata!
}

type TokenPriceMetadata {
    recalculatedAt: DateTime!
    largestBnbReserve: BigInt!
}

type Hypervisor @entity {
    id: ID!

    pool: Pool!

    basePosition: LiquidityPosition
    limitPosition: LiquidityPosition
}

type Bribe @entity {
    id: ID!
    pool: Pool!
}

type Gauge @entity {
    id: ID!

    pool: Pool!
    totalSupply: BigInt!

    externalBribe: Bribe!
    internalBribe: Bribe!

    isAlive: Boolean!
}

type GaugeStake @entity {
    id: ID!

    gauge: Gauge!
    user: User!

    value: BigInt!
    totalReward: BigInt!
}

# type GaugeStakeUpdate @entity {
#     id: ID!

#     # meatadata
#     blockNumber: Int!
#     timestamp: DateTime!
#     txHash: String!

#     stake: GaugeStake!

#     amount: BigInt!
# }

# type GaugeStakeReward @entity {
#     id: ID!

#     # meatadata
#     blockNumber: Int!
#     timestamp: DateTime!
#     txHash: String!

#     stake: GaugeStake!

#     amount: BigInt!
# }

type Vote @entity {
    id: ID!

    user: User!
    token: VeToken!
    pool: Pool!

    weight: Float!
}

type VeToken @entity {
    id: ID!

    owner: User!

    value: BigInt!
    lockedUntil: DateTime!

    totalReward: BigInt!
}
