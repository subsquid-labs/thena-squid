type User @entity {
    id: ID!
    balance: BigInt!
    firstInteractAt: DateTime!
    trades: [Trade!]! @derivedFrom(field: "user")
}

type Trade @entity {
    id: ID!

    # meatadata
    blockNumber: Int!
    timestamp: DateTime!
    txHash: String!

    # in
    tokenInId: ID!
    amountIn: BigInt!
    amountInUSD: Float!

    # out
    tokenOutId: ID!
    amountOut: BigInt!
    amountOutUSD: Float!

    userId: ID!
    routes: [String!]!

    # relations
    "@private Use tokenInId instead"
    tokenIn: Token!
    "@private Use tokenOutId instead"
    tokenOut: Token!
    "@private Use userId instead"
    user: User!
}

type Pool @entity {
    id: ID!

    # token0
    token0Id: ID!
    price0: BigInt!
    reserve0: BigInt!

    # token1
    token1Id: ID!
    reserve1: BigInt!
    price1: BigInt!

    liquidity: BigInt!
    stable: Boolean
    factory: String!
    # minimumLiquidity: BigInt!

    # relations
    "@private Use token0Id instead"
    token0: Token!
    "@private Use token1Id instead"
    token1: Token!
}

type LiquidityPosition @entity {
    id: ID!

    userId: ID!
    poolId: ID!
    value: BigInt!

    # relations
    "@private Use userId instead"
    user: User!
    "@private Use poolId instead"
    pool: Pool!
    "@private Don't use"
    updates: [LiquidityPositionUpdate!]! @derivedFrom(field: "position")
}

type LiquidityPositionUpdate @entity {
    id: ID!
    blockNumber: Int!
    timestamp: DateTime!
    txHash: String!
    positionId: ID!
    amount: BigInt!
    amount0: BigInt!
    amount1: BigInt!

    # relations
    "Use positionId instead"
    position: LiquidityPosition!
}

type Token @entity {
    id: ID!
    decimals: Int!
    bnbPrice: BigInt!
    priceMetadata: TokenPriceMetadata!
}

type TokenPriceMetadata {
    recalculatedAt: DateTime!
    largestBnbReserve: BigInt!
}

type Hypervisor @entity {
    id: ID!

    poolId: ID!

    # relations
    basePosition: LiquidityPosition!
    limitPosition: LiquidityPosition!
    "Use poolId instead"
    pool: Pool!
}
